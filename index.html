<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Learn English by Watching Movies</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <style>
    :root { --bar-h: 96px; }

    body {
      margin: 0;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, sans-serif;
      background: #0f172a;
      color: #e5e7eb;
    }
    body:focus { outline: none; }

    .container {
      max-width: 720px;
      margin: 0 auto;
      padding: 16px 16px calc(var(--bar-h) + 90px);
      box-sizing: border-box;
    }

    .page-title {
      font-size: 20px;
      font-weight: 650;
      margin-bottom: 10px;
    }

    .topbar {
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-bottom: 12px;
    }

    .hint {
      font-size: 13px;
      color: #9ca3af;
      line-height: 1.4;
    }

    .sentence {
      margin-bottom: 22px;
      scroll-margin-bottom: calc(var(--bar-h) + 16px);

      padding: 8px;
      margin-left: -8px;
      margin-right: -8px;
      border-radius: 10px;
    }

    /* Flash background (temporary) */
    .sentence.flash-bg {
      animation: flash-bg 1s ease-in-out 0s 1;
    }
    
    /* Permanent underline for located sentence */
    .sentence.marked .en {
      text-decoration-line: underline;
      text-decoration-thickness: 1px;          /* üëà ÊØî‰πãÂâçÊõ¥ÁªÜ */
      text-decoration-color: #22c55e;
      text-underline-offset: 5px;              /* Á®çÂæÆÈù†ËøëÊñáÂ≠ó */
    }
    
    @keyframes flash-bg {
      0% {
        background: rgba(34,197,94,0.00);
      }
      50% {
        background: rgba(34,197,94,0.16);
      }
      100% {
        background: rgba(34,197,94,0.00);
      }
    }

    .sentence.marked .en {
      text-decoration-skip-ink: auto;
    }

    .en {
      font-size: 18px;
      line-height: 1.6;
      word-wrap: break-word;
    }

    .word {
      cursor: pointer;
      padding: 2px 4px;
      border-radius: 4px;
    }
    .word:hover { background: #1e293b; }

    .cn {
      margin-top: 6px;
      font-size: 15px;
      color: #9ca3af;
      line-height: 1.45;
      word-break: break-word;
      white-space: pre-wrap;
    }

    .star {
      cursor: pointer;
      font-size: 18px;
      margin-left: 0;
      user-select: none;
    }

    .speaker-inline {
      cursor: pointer;
      user-select: none;
      font-size: 16px;
      opacity: 0.95;
    }
    .speaker-inline:hover { opacity: 1; }

    /* Bottom bar (always 2 rows; stable height) */
    .controls {
      position: fixed;
      bottom: 0; left: 0; right: 0;
      background: #020617;
      padding: 10px 12px;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      gap: 10px;
      min-height: var(--bar-h);
      z-index: 50;
    }

    .controls-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      min-height: 34px;
    }

    .nav-row {
      display: flex;
      gap: 14px;
      align-items: center;
      font-size: 14px;
      color: #cbd5f5;

      /* keep bar height stable */
      flex-wrap: nowrap;
      white-space: nowrap;
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
      scrollbar-width: none;
    }
    .nav-row::-webkit-scrollbar { display: none; }

    .nav {
      cursor: pointer;
      user-select: none;
      opacity: 0.95;
    }
    .nav:hover { opacity: 1; }

    .icon-btn {
      border: 1px solid #334155;
      background: transparent;
      color: #cbd5f5;
      border-radius: 999px;
      width: 36px;
      height: 32px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      user-select: none;
      flex: 0 0 auto;
    }
    .icon-btn:hover { border-color: #475569; }

    .chk-row {
      display: flex;
      align-items: center;
      gap: 14px;
      font-size: 14px;
      color: #cbd5f5;
      white-space: nowrap;
      overflow: hidden;
    }

    .chk {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      user-select: none;
    }

    .next-btn {
      padding: 12px 40px;
      font-size: 18px;
      border-radius: 999px;
      border: none;
      background: #22c55e;
      color: #022c22;
      cursor: pointer;
      flex: 0 0 auto;
    }
    .next-btn:disabled {
      background: #334155;
      color: #94a3b8;
      cursor: not-allowed;
    }

    /* Keep layout space while visually hidden */
    .hidden-but-keeps-space {
      visibility: hidden !important;
      pointer-events: none !important;
    }

    /* Popover */
    .popover {
      position: absolute;
      background: #020617;
      border-radius: 12px;
      padding: 12px 14px;
      box-shadow: 0 8px 24px rgba(0,0,0,0.4);
      z-index: 999;
      display: none;
      max-width: 320px;
      width: fit-content;
      box-sizing: border-box;
    }

    .popover h4 {
      margin: 0 0 8px;
      font-size: 18px;
      font-weight: 650;
    }

    .ipa-line {
      display: flex;
      align-items: center;
      gap: 6px; /* close to "one space" feeling */
      margin-bottom: 8px;
      color: #9ca3af;
      font-size: 14px;
    }

    .speaker {
      cursor: pointer;
      user-select: none;
    }
    .speaker.disabled {
      opacity: 0.35;
      cursor: default;
    }

    .cn-def {
      font-size: 14px;
      color: #cbd5f5;
      line-height: 1.4;
      word-break: break-word;
    }
    .cn-item { margin: 3px 0; }

    .loading { font-size: 13px; color: #9ca3af; }

    /* Grouped lists */
    .list-title {
      font-size: 18px;
      font-weight: 650;
      margin: 10px 0 14px;
    }

    .group {
      margin: 14px 0 18px;
      padding: 12px;
      border: 1px solid #1f2937;
      border-radius: 12px;
      background: rgba(2,6,23,0.35);
    }

    .group-head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      margin-bottom: 10px;
    }

    .group-name {
      font-size: 14px;
      font-weight: 650;
      color: #cbd5f5;
      word-break: break-word;
    }

    .group-actions {
      display: flex;
      gap: 10px;
      align-items: center;
      flex-shrink: 0;
    }

    .small-btn {
      padding: 8px 10px;
      font-size: 12px;
      border-radius: 999px;
      border: 1px solid #334155;
      background: transparent;
      color: #cbd5f5;
      cursor: pointer;
    }
    .small-btn:hover { border-color: #475569; }

    .list-item {
      margin-bottom: 12px;
      cursor: default;
    }

    .clickable {
      cursor: pointer;
    }

    .meta {
      font-size: 12px;
      color: #94a3b8;
      margin-top: 4px;
    }

    /* Hide file input in non-study view */
    .hidden { display: none !important; }
  </style>
</head>

<body tabindex="-1">
  <div class="container">
    <div class="page-title">Learn English by Watching Movies</div>

    <div class="topbar">
      <div id="fileBox">
        <input type="file" accept=".txt" id="fileInput" />
      </div>
      <div id="hint" class="hint"></div>
    </div>

    <div id="app"></div>
  </div>

  <!-- Bottom controls: always 2 rows -->
  <div class="controls" id="controlsBar">
    <div class="controls-row">
      <div class="nav-row">
        <span class="nav" id="navStudy">üè† Study</span>
        <span class="nav" id="navVocab">üìò Vocabulary</span>
        <span class="nav" id="navHighlights">üí¨ Highlights</span>
      </div>
      <button class="icon-btn" id="restartBtn" title="Restart" aria-label="Restart">‚ü≤</button>
    </div>

    <div class="controls-row">
      <div class="chk-row">
        <label class="chk">
          <input type="checkbox" checked id="toggleCN" />
          Show Chinese
        </label>
        <label class="chk">
          <input type="checkbox" id="toggleAuto" />
          Auto
        </label>
      </div>
      <button class="next-btn" id="nextBtn" disabled>Next</button>
    </div>
  </div>

  <div id="popover" class="popover"></div>

<script>
/* =========================
   IndexedDB (Promise wrapper)
   ========================= */

class IDBStore {
  constructor(dbName, dbVersion) {
    this.dbName = dbName;
    this.dbVersion = dbVersion;
    this.db = null;
  }

  async init() {
    if (this.db) return this.db;

    this.db = await new Promise((resolve, reject) => {
      const req = indexedDB.open(this.dbName, this.dbVersion);

      req.onupgradeneeded = (e) => {
        const db = e.target.result;

        // words store: key = word
        if (!db.objectStoreNames.contains("words")) {
          const w = db.createObjectStore("words", { keyPath: "word" });
          w.createIndex("fileName", "fileName", { unique: false });
          w.createIndex("savedAt", "savedAt", { unique: false });
        } else {
          const tx = e.target.transaction;
          const w = tx.objectStore("words");
          if (!w.indexNames.contains("fileName")) w.createIndex("fileName", "fileName", { unique: false });
          if (!w.indexNames.contains("savedAt")) w.createIndex("savedAt", "savedAt", { unique: false });
        }

        // sentences store: key = id `${fileName}::${idx}`
        if (!db.objectStoreNames.contains("sentences")) {
          const s = db.createObjectStore("sentences", { keyPath: "id" });
          s.createIndex("fileName", "fileName", { unique: false });
          s.createIndex("savedAt", "savedAt", { unique: false });
        } else {
          const tx = e.target.transaction;
          const s = tx.objectStore("sentences");
          if (!s.indexNames.contains("fileName")) s.createIndex("fileName", "fileName", { unique: false });
          if (!s.indexNames.contains("savedAt")) s.createIndex("savedAt", "savedAt", { unique: false });
        }

        // progress: key=fileName
        if (!db.objectStoreNames.contains("progress")) {
          db.createObjectStore("progress", { keyPath: "fileName" });
        }

        // meta: key/value
        if (!db.objectStoreNames.contains("meta")) {
          db.createObjectStore("meta", { keyPath: "key" });
        }
      };

      req.onsuccess = () => resolve(req.result);
      req.onerror = () => reject(req.error);
    });

    return this.db;
  }

  _store(storeName, mode = "readonly") {
    const tx = this.db.transaction(storeName, mode);
    return tx.objectStore(storeName);
  }

  async get(storeName, key) {
    await this.init();
    return new Promise((resolve, reject) => {
      const req = this._store(storeName, "readonly").get(key);
      req.onsuccess = () => resolve(req.result || null);
      req.onerror = () => reject(req.error);
    });
  }

  async put(storeName, value) {
    await this.init();
    return new Promise((resolve, reject) => {
      const req = this._store(storeName, "readwrite").put(value);
      req.onsuccess = () => resolve(true);
      req.onerror = () => reject(req.error);
    });
  }

  async del(storeName, key) {
    await this.init();
    return new Promise((resolve, reject) => {
      const req = this._store(storeName, "readwrite").delete(key);
      req.onsuccess = () => resolve(true);
      req.onerror = () => reject(req.error);
    });
  }

  async getAll(storeName) {
    await this.init();
    return new Promise((resolve, reject) => {
      const req = this._store(storeName, "readonly").getAll();
      req.onsuccess = () => resolve(req.result || []);
      req.onerror = () => reject(req.error);
    });
  }

  async bulkDelete(storeName, keys) {
    await this.init();
    if (!keys || keys.length === 0) return true;

    return new Promise((resolve, reject) => {
      const store = this._store(storeName, "readwrite");
      let i = 0;

      const next = () => {
        if (i >= keys.length) return resolve(true);
        const req = store.delete(keys[i++]);
        req.onsuccess = next;
        req.onerror = () => reject(req.error);
      };

      next();
    });
  }
}

/* =========================
   Sentence TTS (English only)
   ========================= */

class SentenceSpeaker {
  constructor() {
    this.synth = window.speechSynthesis || null;
    this.voice = null;
    this.voicesReady = false;

    if (this.synth) {
      const tryLoad = () => {
        const voices = this.synth.getVoices();
        if (voices && voices.length) {
          this.voicesReady = true;
          this.voice = this._pickUSVoice(voices);
        }
      };

      tryLoad();
      this.synth.onvoiceschanged = () => {
        this.voicesReady = true;
        this.voice = this._pickUSVoice(this.synth.getVoices());
      };
    }
  }

  _pickUSVoice(voices) {
    if (!Array.isArray(voices) || voices.length === 0) return null;

    const us = voices.filter(v => String(v.lang || "").toLowerCase().startsWith("en-us"));
    if (us.length === 0) return voices.find(v => String(v.lang || "").toLowerCase().startsWith("en")) || null;

    // Prefer common US voices if present
    const preferred = us.find(v => /google us english/i.test(v.name || "")) ||
                      us.find(v => /united states/i.test(v.name || "")) ||
                      us[0];
    return preferred || us[0] || null;
  }

  stop() {
    if (!this.synth) return;
    try { this.synth.cancel(); } catch {}
  }

  speak(text) {
    const t = String(text || "").trim();
    if (!t || !this.synth) return Promise.resolve(false);

    this.stop();

    return new Promise((resolve) => {
      const utter = new SpeechSynthesisUtterance(t);
      utter.lang = "en-US";
      if (this.voice) utter.voice = this.voice;

      // Keep default rate/pitch (stable across devices)
      utter.rate = 1;
      utter.pitch = 1;

      let done = false;

      // Safety timeout (avoid rare cases where onend never fires)
      const maxMs = Math.min(60000, Math.max(12000, t.length * 140));
      const timer = setTimeout(() => {
        if (done) return;
        done = true;
        this.stop();
        resolve(false);
      }, maxMs);

      utter.onend = () => {
        if (done) return;
        done = true;
        clearTimeout(timer);
        resolve(true);
      };

      utter.onerror = () => {
        if (done) return;
        done = true;
        clearTimeout(timer);
        resolve(false);
      };

      try {
        this.synth.speak(utter);
      } catch {
        clearTimeout(timer);
        resolve(false);
      }
    });
  }
}

/* =========================
   Dictionary: US IPA + US audio + Chinese meanings (no caching)
   ========================= */

class DictionaryService {
  constructor() {
    this.audioPlayer = new Audio();
  }

  normalize(word) {
    return String(word || "").trim().toLowerCase();
  }

  async lookup(word) {
    const w = this.normalize(word);
    if (!w) return null;

    const dict = await this._fetchDictionaryEntry(w);
    const zhList = await this._fetchChineseList(w, dict.definitions);

    return {
      ipaUS: dict.ipaUS || "",
      audioUS: dict.audioUS || "",
      zhList
    };
  }

  async playUS(word) {
    const w = this.normalize(word);
    if (!w) return false;

    const data = await this.lookup(w);
    if (!data?.audioUS) return false;

    try {
      this.audioPlayer.src = data.audioUS;
      await this.audioPlayer.play();
      return true;
    } catch {
      return false;
    }
  }

  async _fetchDictionaryEntry(wordLower) {
    const out = { ipaUS: "", audioUS: "", definitions: [] };

    try {
      const res = await fetch(`https://api.dictionaryapi.dev/api/v2/entries/en/${encodeURIComponent(wordLower)}`);
      const json = await res.json();
      if (!Array.isArray(json)) return out;

      const phonetics = [];
      const defs = [];

      for (const entry of json) {
        if (Array.isArray(entry?.phonetics)) {
          for (const p of entry.phonetics) {
            phonetics.push({ text: p?.text || "", audio: p?.audio || "" });
          }
        }

        if (Array.isArray(entry?.meanings)) {
          for (const m of entry.meanings) {
            if (Array.isArray(m?.definitions)) {
              for (const d of m.definitions) {
                const def = String(d?.definition || "").trim();
                if (def) defs.push(def);
              }
            }
          }
        }
      }

      const isUsAudio = (url) => {
        const u = String(url || "").toLowerCase();
        return u.includes("-us.mp3") || u.endsWith("us.mp3") || u.includes("en-us");
      };

      // Prefer US audio + matching IPA
      for (const p of phonetics) {
        if (p.audio && isUsAudio(p.audio)) {
          if (!out.audioUS) out.audioUS = p.audio;
          if (!out.ipaUS && p.text) out.ipaUS = p.text;
        }
        if (out.audioUS && out.ipaUS) break;
      }

      if (!out.ipaUS) out.ipaUS = phonetics.find(p => p.text)?.text || "";
      out.definitions = defs;

      return out;
    } catch {
      return out;
    }
  }

  async _fetchChineseList(wordLower, englishDefinitions) {
    const zhSet = new Set();

    const add = (s) => {
      const t = String(s || "").trim();
      if (!t) return;
      zhSet.add(t);
    };

    // Translate the word itself
    add(await this._translateToZh(wordLower));

    /* sengo
    // Translate a few dictionary definitions to get richer CN meanings
    const defs = Array.isArray(englishDefinitions) ? englishDefinitions : [];
    const picked = [];
    const seen = new Set();

    for (const d of defs) {
      const x = String(d || "").trim();
      if (!x) continue;
      if (seen.has(x)) continue;
      seen.add(x);
      picked.push(x);
      if (picked.length >= 5) break;
    }

    for (const d of picked) {
      add(await this._translateToZh(d));
    }
    */
    
    return Array.from(zhSet);
  }

  async _translateToZh(textEn) {
    const q = String(textEn || "").trim();
    if (!q) return "";

    try {
      const url = `https://api.mymemory.translated.net/get?q=${encodeURIComponent(q)}&langpair=en|zh-CN`;
      const res = await fetch(url);
      const json = await res.json();

      // Main translation
      const main = String(json?.responseData?.translatedText || "").trim();
      const out = [];

      if (main && main.toLowerCase() !== q.toLowerCase()) out.push(main);

      // Additional candidates (often multiple senses)
      const matches = Array.isArray(json?.matches) ? json.matches : [];
      for (const m of matches) {
        const t = String(m?.translation || "").trim();
        if (!t) continue;
        if (t.toLowerCase() === q.toLowerCase()) continue;
        out.push(t);
        if (out.length >= 20) break;
      }

      // Deduplicate while preserving order
      const seen = new Set();
      const unique = [];
      for (const t of out) {
        if (seen.has(t)) continue;
        seen.add(t);
        unique.push(t);
      }

      // Return as a single joined string for this call (caller dedups across calls)
      return unique.join("Ôºõ");
    } catch {
      return "";
    }
  }
}

/* =========================
   App
   ========================= */

class MovieEnglishApp {
  constructor() {
    this.db = new IDBStore("learn-english-db", 3);
    this.dict = new DictionaryService();
    this.speaker = new SentenceSpeaker();

    // UI refs
    this.appEl = document.getElementById("app");
    this.popoverEl = document.getElementById("popover");
    this.hintEl = document.getElementById("hint");

    this.fileBoxEl = document.getElementById("fileBox");
    this.fileInputEl = document.getElementById("fileInput");

    this.toggleCNEl = document.getElementById("toggleCN");
    this.toggleAutoEl = document.getElementById("toggleAuto");
    this.nextBtnEl = document.getElementById("nextBtn");
    this.restartBtnEl = document.getElementById("restartBtn");

    this.navStudyEl = document.getElementById("navStudy");
    this.navVocabEl = document.getElementById("navVocab");
    this.navHighlightsEl = document.getElementById("navHighlights");

    this.controlsBar = document.getElementById("controlsBar");

    // runtime state
    this.view = "study";
    this.showCN = true;
    this.autoMode = false;

    this.currentFileName = null;
    this.sentences = []; // [{ idx, en, cn }]
    this.cursor = -1;
    this.isFinished = false;

    // favorites
    this.favoriteWords = new Set();       // wordLower
    this.favoriteSentenceIds = new Set(); // all sentence ids across files

    // popover state
    this.currentPopoverWord = null;
    this.currentPopoverData = null;

    // auto playback token (for cancellation)
    this.autoToken = 0;
  }

  async init() {
    await this.db.init();

    // Keep bar height variable accurate
    this._syncBarHeightVar();
    window.addEventListener("resize", () => this._syncBarHeightVar());

    // Load prefs
    const showCNMeta = await this.db.get("meta", "showCN");
    if (showCNMeta && typeof showCNMeta.value === "boolean") {
      this.showCN = showCNMeta.value;
      this.toggleCNEl.checked = this.showCN;
    }

    const autoMeta = await this.db.get("meta", "autoMode");
    if (autoMeta && typeof autoMeta.value === "boolean") {
      this.autoMode = autoMeta.value;
      this.toggleAutoEl.checked = this.autoMode;
    }

    // Load favorites
    await this._loadFavoriteWords();
    await this._loadFavoriteSentencesAll();

    // Hint
    await this._renderLastSessionHint();

    // Bind UI
    this._bindUI();
    this._bindGlobal();

    // Focus
    window.addEventListener("load", () => document.body.focus());

    // Initial controls
    this._syncControls();
    this._syncRestartVisibility();
  }

  _syncBarHeightVar() {
    const h = Math.max(88, this.controlsBar.getBoundingClientRect().height);
    document.documentElement.style.setProperty("--bar-h", `${Math.round(h)}px`);
  }

  _bindUI() {
    this.fileInputEl.addEventListener("change", (e) => this._onFileSelected(e));

    this.toggleCNEl.addEventListener("change", async () => {
      this.showCN = this.toggleCNEl.checked;
      await this.db.put("meta", { key: "showCN", value: this.showCN });

      if (this.view === "study") this.renderStudy();
      if (this.view === "vocab") await this.renderVocabulary();
      if (this.view === "highlights") await this.renderHighlights();
    });

    this.toggleAutoEl.addEventListener("change", async () => {
      this.autoMode = this.toggleAutoEl.checked;
      await this.db.put("meta", { key: "autoMode", value: this.autoMode });

      // Turning auto off should stop any running loop immediately
      if (!this.autoMode) this.stopAuto();
      document.body.focus();
    });

    this.nextBtnEl.addEventListener("click", () => this.onNextClicked());
    this.restartBtnEl.addEventListener("click", () => this.restart());

    this.navStudyEl.addEventListener("click", () => this.setView("study"));
    this.navVocabEl.addEventListener("click", () => this.setView("vocab"));
    this.navHighlightsEl.addEventListener("click", () => this.setView("highlights"));

    // Delegation
    this.appEl.addEventListener("click", (e) => this._handleAppClick(e));
    this.popoverEl.addEventListener("click", (e) => this._handlePopoverClick(e));

    this.appEl.addEventListener("click", (e) => {
      if (this.view !== "study") return;
    
      const target = e.target;
    
      // ÊéíÈô§Âº∫‰∫§‰∫íÂÖÉÁ¥†
      if (
        target.closest(
          ".word, .speaker-inline, .speaker, .star, button, a, input, label"
        )
      ) return;
    
      // ÊéíÈô§ Popover
      if (this.popoverEl.contains(target)) return;
    
      // ÂΩìÂâçÊòæÁ§∫ÁöÑÊúÄÂêé‰∏ÄÂè•
      const shownCount = this.cursor + 1;
      if (shownCount <= 0) return;
    
      const lastIdx = this.sentences[shownCount - 1]?.idx;
      if (lastIdx === undefined) return;
    
      const lastEl = document.getElementById(`sent-${lastIdx}`);
      if (!lastEl) return;
    
      // Âè™ÂÖÅËÆ∏ÁÇπÂáª‚ÄúÊúÄÂêé‰∏ÄÂè•‰∏ãÈù¢ÁöÑÁ©∫ÁôΩ‚Äù
      const rect = lastEl.getBoundingClientRect();
      const clickY = e.clientY;
      if (clickY <= rect.bottom + 6) return;
    
      // ‚úÖ ÊûÅËΩªÂèçÈ¶àÔºà120msÔºå‰∏çÂΩ±ÂìçÈòÖËØªÔºâ
      lastEl.classList.add("tap-feedback");
      setTimeout(() => {
        lastEl.classList.remove("tap-feedback");
      }, 120);
    
      // Next
      this.onNextClicked();
    });

 
  }

  _bindGlobal() {
    document.addEventListener("keydown", (e) => {
      const tag = (document.activeElement?.tagName || "").toUpperCase();

      // Space = Next (Study only), avoid when typing or focusing form elements
      if (e.code === "Space" && this.view === "study" && tag !== "INPUT" && tag !== "TEXTAREA" && tag !== "BUTTON" && tag !== "SELECT") {
        e.preventDefault();
        this.onNextClicked();
      }
    });

    document.addEventListener("click", (e) => {
      const within = this.popoverEl.contains(e.target);
      const isWord = e.target?.classList?.contains("word");
      if (!within && !isWord) this.hidePopover();
    });
  }

  async _onFileSelected(e) {
    const file = e.target.files?.[0];
    if (!file) return;

    // Selecting a file should always return to Study
    await this.setView("study");

    // Stop auto playback whenever loading a file
    this.stopAuto();

    this.currentFileName = file.name;

    const text = await file.text();
    this._parseSubtitleText(text);

    await this._restoreProgressForFile(this.currentFileName);

    this.renderStudy({ autoScroll: true });

    this._syncControls();
    this._syncRestartVisibility();

    requestAnimationFrame(() => {
      try { this.fileInputEl.blur(); } catch {}
      document.body.focus();
    });

    // Avoid leaving focus on the file input (space key issue)
    try { this.fileInputEl.blur(); } catch {}
    document.body.focus();
  }

  _parseSubtitleText(text) {
    const lines = String(text).split(/\r?\n/).map(s => s.trim()).filter(Boolean);
    this.sentences = [];

    // Format: CN line then EN line (pairs)
    for (let i = 0; i < lines.length - 1; i += 2) {
      const idx = i / 2;
      this.sentences.push({ idx, cn: lines[i], en: lines[i + 1] });
    }

    if (this.sentences.length === 0) {
      this.cursor = -1;
      this.isFinished = false;
    }
  }

  async _restoreProgressForFile(fileName) {
    const rec = await this.db.get("progress", fileName);
    const maxCursor = this.sentences.length - 1;

    if (rec && typeof rec.cursor === "number") {
      this.cursor = Math.max(-1, Math.min(rec.cursor, maxCursor));
    } else {
      this.cursor = -1;
    }

    this.isFinished = (this.sentences.length > 0 && this.cursor >= maxCursor);

    if (this.sentences.length > 0) {
      const shown = Math.max(0, this.cursor + 1);
      this.hintEl.textContent =
        `Loaded: ${fileName}. ` +
        (shown > 0 ? `Resumed at sentence ${shown}/${this.sentences.length}.` : `Press Next to start.`) +
        ` (Select the same file next time to auto-resume.)`;
    } else {
      this.hintEl.textContent = `Loaded: ${fileName}, but no valid subtitle pairs were detected.`;
    }
  }

  async _saveProgress() {
    if (!this.currentFileName) return;

    await this.db.put("progress", {
      fileName: this.currentFileName,
      cursor: this.cursor,
      updatedAt: Date.now()
    });

    await this.db.put("meta", { key: "lastFileName", value: this.currentFileName });
  }

  async _renderLastSessionHint() {
    const last = await this.db.get("meta", "lastFileName");
    if (last?.value) {
      const p = await this.db.get("progress", last.value);
      if (p && typeof p.cursor === "number") {
        const n = Math.max(0, p.cursor + 1);
        this.hintEl.textContent = `Last session: ${last.value}, sentence ${n}. Select the same file to auto-resume.`;
        return;
      }
      this.hintEl.textContent = `Last session: ${last.value}. Select the same file to resume.`;
      return;
    }
    this.hintEl.textContent = `Select a bilingual subtitle TXT file to start.`;
  }

  async _loadFavoriteWords() {
    const rows = await this.db.getAll("words");
    this.favoriteWords = new Set(rows.map(r => r.word));
  }

  async _loadFavoriteSentencesAll() {
    const rows = await this.db.getAll("sentences");
    this.favoriteSentenceIds = new Set(rows.map(r => r.id));
  }

  _sentenceKey(fileName, idx) {
    return `${fileName}::${idx}`;
  }

  _hasFileLoaded() {
    return !!this.currentFileName && this.sentences.length > 0;
  }

  stopAuto() {
    this.autoToken += 1;
    this.speaker.stop();
  }

  async setView(view) {
    // Switching views should stop auto playback
    if (view !== "study") this.stopAuto();

    this.view = view;

    // File chooser only in Study
    if (view === "study") this.fileBoxEl.classList.remove("hidden");
    else this.fileBoxEl.classList.add("hidden");

    // Keep Next button space but hide outside Study
    if (view === "study") this.nextBtnEl.classList.remove("hidden-but-keeps-space");
    else this.nextBtnEl.classList.add("hidden-but-keeps-space");

    // Restart icon: visible only in Study and only when a file is loaded
    this._syncRestartVisibility();

    this.hidePopover();
    this._syncControls();

    if (view === "study") this.renderStudy();
    if (view === "vocab") await this.renderVocabulary();
    if (view === "highlights") await this.renderHighlights();

    document.body.focus();
  }

  _syncRestartVisibility() {
    const show = (this.view === "study" && this._hasFileLoaded());
    this.restartBtnEl.classList.toggle("hidden-but-keeps-space", !show);
  }

  _syncControls() {
    const hasFile = this._hasFileLoaded();

    if (!hasFile) {
      this.nextBtnEl.disabled = true;
      this.nextBtnEl.textContent = "Next";
      return;
    }

    this.nextBtnEl.disabled = false;
    this.nextBtnEl.textContent = this.isFinished ? "Finish" : "Next";
  }

  async onNextClicked() {
    if (this.view !== "study") return;

    // If finished, Finish behaves like a button (not disabled)
    if (this._hasFileLoaded() && this.isFinished) {
      this.stopAuto();
      alert("Finished üéâ");
      document.body.focus();
      return;
    }

    const advanced = await this.stepNext({ autoTriggered: false });
    if (!advanced) return;

    // Auto mode: speak current sentence and then auto-next
    if (this.autoMode) {
      this.startAutoFromCurrent();
    }

    document.body.focus();
  }

  async stepNext({ autoTriggered }) {
    if (this.view !== "study") return false;
    if (!this._hasFileLoaded()) return false;

    const lastIdx = this.sentences.length - 1;

    if (this.isFinished) {
      if (!autoTriggered) alert("Finished üéâ");
      return false;
    }

    if (this.cursor < lastIdx) {
      this.cursor += 1;
      this.isFinished = (this.cursor >= lastIdx);

      // Save progress in background
      this._saveProgress();

      this.renderStudy({ autoScroll: true });
      this._syncControls();
      this._syncRestartVisibility();
      return true;
    }

    return false;
  }

  async startAutoFromCurrent() {
    if (!this.autoMode) return;
    if (this.view !== "study") return;
    if (!this._hasFileLoaded()) return;

    const token = ++this.autoToken;

    // Speak current sentence, then wait 1s, then auto-next (repeat)
    while (this.autoMode && this.view === "study" && this._hasFileLoaded() && token === this.autoToken) {
      const s = this.sentences[this.cursor];
      if (!s) break;

      await this.speaker.speak(s.en);

      if (token !== this.autoToken) break;
      if (!this.autoMode) break;
      if (this.isFinished) break;

      await new Promise((r) => setTimeout(r, 1000));

      if (token !== this.autoToken) break;
      if (!this.autoMode) break;

      const advanced = await this.stepNext({ autoTriggered: true });
      if (!advanced) break;
    }
  }

  restart() {
    if (this.view !== "study") return;
    if (!this._hasFileLoaded()) return;

    const ok = confirm("Restart from the beginning?");
    if (!ok) return;

    this.stopAuto();

    this.cursor = -1;
    this.isFinished = false;
    this._saveProgress();

    this.renderStudy();
    this._syncControls();

    this.hintEl.textContent = `Restarted: ${this.currentFileName}. Press Next to start.`;
    document.body.focus();
  }

  renderStudy({ scrollToIdx = null, autoScroll = false } = {}) {
    this.appEl.innerHTML = "";

    const shown = this.sentences.slice(0, this.cursor + 1);
    const frag = document.createDocumentFragment();

    for (const s of shown) {
      const wrap = document.createElement("div");
      wrap.className = "sentence";
      wrap.dataset.sentenceIdx = String(s.idx);
      wrap.id = `sent-${s.idx}`;

      const en = document.createElement("div");
      en.className = "en";

      // Clickable words
      const tokens = s.en.split(" ");
      tokens.forEach((tok, i) => {
        const clean = tok.replace(/[^a-zA-Z']/g, "");
        const span = document.createElement("span");
        span.className = "word";
        span.textContent = tok;
        span.dataset.word = clean;
        en.appendChild(span);
        if (i !== tokens.length - 1) en.appendChild(document.createTextNode(" "));
      });

      // Sentence speaker (TTS) before star
      const speak = document.createElement("span");
      speak.className = "speaker-inline";
      speak.dataset.action = "playSentence";
      speak.dataset.idx = String(s.idx);
      speak.title = "Read sentence";
      speak.textContent = "üîä";

      // Sentence star
      const sid = this._sentenceKey(this.currentFileName, s.idx);
      const star = document.createElement("span");
      star.className = "star";
      star.dataset.action = "toggleSentence";
      star.dataset.sentenceId = sid;
      star.textContent = this.favoriteSentenceIds.has(sid) ? "‚òÖ" : "‚òÜ";

      en.appendChild(document.createTextNode(" "));
      en.appendChild(speak);
      en.appendChild(document.createTextNode(" "));
      en.appendChild(star);

      wrap.appendChild(en);

      if (this.showCN) {
        const cn = document.createElement("div");
        cn.className = "cn";
        cn.textContent = s.cn;
        wrap.appendChild(cn);
      }

      frag.appendChild(wrap);
    }

    this.appEl.appendChild(frag);

    // Scroll target: specific sentence (e.g., from Highlights) OR the latest shown
    let targetEl = null;

    if (typeof scrollToIdx === "number" && Number.isFinite(scrollToIdx)) {
      targetEl = document.getElementById(`sent-${scrollToIdx}`);
    }
    if (!targetEl && shown.length) {
      targetEl = document.getElementById(`sent-${shown[shown.length - 1].idx}`);
    }

    if (autoScroll && targetEl) {
      this._scrollSentenceFullyVisible(targetEl);
    }

  }

  _scrollSentenceFullyVisible(el) {
    // Ensure the element's bottom is not covered by the bottom controls
    const rect = el.getBoundingClientRect();
    const barH = this.controlsBar.getBoundingClientRect().height;
    const padding = 10;

    // First, bring it into view roughly
    el.scrollIntoView({ behavior: "smooth", block: "end" });

    // Then compensate if the bottom is still covered
    setTimeout(() => {
      const r = el.getBoundingClientRect();
      const visibleBottom = window.innerHeight - barH - padding;
      const diff = r.bottom - visibleBottom;
      if (diff > 0) {
        window.scrollBy({ top: diff + 6, left: 0, behavior: "smooth" });
      }
    }, 200);
  }

  /* ---------- Grouping helpers ---------- */

  _groupByFileName(items, fileNameField = "fileName") {
    const groups = new Map(); // fileName -> { name, items[], newestSavedAt }
    for (const it of items) {
      const nameRaw = it?.[fileNameField];
      const name = (nameRaw && String(nameRaw).trim()) ? String(nameRaw).trim() : "Other";
      if (!groups.has(name)) groups.set(name, { name, items: [], newestSavedAt: 0 });
      const g = groups.get(name);
      g.items.push(it);
      const t = Number(it.savedAt || 0);
      if (t > g.newestSavedAt) g.newestSavedAt = t;
    }

    // Groups: newest first
    const arr = Array.from(groups.values());
    arr.sort((a, b) => (b.newestSavedAt || 0) - (a.newestSavedAt || 0));

    // Items: newest first
    for (const g of arr) {
      g.items.sort((a, b) => (b.savedAt || 0) - (a.savedAt || 0));
    }

    return arr;
  }

  _normalizeZhList(record) {
    if (Array.isArray(record?.zhList) && record.zhList.length) return record.zhList;
    const z = String(record?.zh || "").trim();
    return z ? [z] : [];
  }

  _renderZhBlock(parentEl, zhList) {
    if (!this.showCN) return;
    const list = Array.isArray(zhList) ? zhList : [];
    if (list.length === 0) return;

    const cn = document.createElement("div");
    cn.className = "cn";

    // If some items are joined by "Ôºõ" already, keep them as-is (full output requested)
    const lines = [];
    for (const x of list) {
      const s = String(x || "").trim();
      if (!s) continue;
      lines.push(s);
    }

    cn.textContent = lines.join("\n");
    parentEl.appendChild(cn);
  }

  /* ---------- Views: Vocabulary / Highlights ---------- */

  async renderVocabulary() {
    this.appEl.innerHTML = "";

    const title = document.createElement("div");
    title.className = "list-title";
    title.textContent = "Vocabulary";
    this.appEl.appendChild(title);

    const rows = await this.db.getAll("words");
    if (rows.length === 0) {
      const empty = document.createElement("div");
      empty.className = "hint";
      empty.textContent = "No saved words yet. Save a word by tapping ‚òÜ in the popover.";
      this.appEl.appendChild(empty);
      return;
    }

    const groups = this._groupByFileName(rows, "fileName");
    const frag = document.createDocumentFragment();

    for (const g of groups) {
      const groupEl = document.createElement("div");
      groupEl.className = "group";

      const head = document.createElement("div");
      head.className = "group-head";

      const name = document.createElement("div");
      name.className = "group-name";
      name.textContent = `${g.name} (${g.items.length})`;

      const actions = document.createElement("div");
      actions.className = "group-actions";

      const delAll = document.createElement("button");
      delAll.className = "small-btn";
      delAll.textContent = "Delete All";
      delAll.dataset.action = "deleteWordGroup";
      delAll.dataset.groupName = g.name;

      actions.appendChild(delAll);
      head.appendChild(name);
      head.appendChild(actions);
      groupEl.appendChild(head);

      for (const r of g.items) {
        const item = document.createElement("div");
        item.className = "list-item";

        const line = document.createElement("div");
        line.className = "en";

        const w = document.createElement("span");
        w.className = "word";
        w.textContent = r.word;
        w.dataset.word = r.word;

        const star = document.createElement("span");
        star.className = "star";
        star.dataset.action = "toggleWord";
        star.dataset.word = r.word;
        star.textContent = "‚òÖ";

        line.appendChild(w);
        line.appendChild(document.createTextNode(" "));
        line.appendChild(star);

        item.appendChild(line);

        // CN under the word line, controlled by Show Chinese
        this._renderZhBlock(item, this._normalizeZhList(r));

        groupEl.appendChild(item);
      }

      frag.appendChild(groupEl);
    }

    this.appEl.appendChild(frag);
  }

  async renderHighlights() {
    this.appEl.innerHTML = "";

    const title = document.createElement("div");
    title.className = "list-title";
    title.textContent = "Highlights";
    this.appEl.appendChild(title);

    const rows = await this.db.getAll("sentences");
    if (rows.length === 0) {
      const empty = document.createElement("div");
      empty.className = "hint";
      empty.textContent = "No saved sentences yet. Save a sentence by tapping ‚òÜ at the end of a line.";
      this.appEl.appendChild(empty);
      return;
    }

    const groups = this._groupByFileName(rows, "fileName");
    const frag = document.createDocumentFragment();

    for (const g of groups) {
      const groupEl = document.createElement("div");
      groupEl.className = "group";

      const head = document.createElement("div");
      head.className = "group-head";

      const name = document.createElement("div");
      name.className = "group-name";
      name.textContent = `${g.name} (${g.items.length})`;

      const actions = document.createElement("div");
      actions.className = "group-actions";

      const delAll = document.createElement("button");
      delAll.className = "small-btn";
      delAll.textContent = "Delete All";
      delAll.dataset.action = "deleteHighlightGroup";
      delAll.dataset.groupName = g.name;

      actions.appendChild(delAll);
      head.appendChild(name);
      head.appendChild(actions);
      groupEl.appendChild(head);

      for (const r of g.items) {
        const item = document.createElement("div");
        item.className = "list-item clickable";
        item.dataset.action = "jumpToSentence";
        item.dataset.fileName = r.fileName ? String(r.fileName) : "";
        item.dataset.idx = String(r.idx);

        const enLine = document.createElement("div");
        enLine.className = "en";
        enLine.textContent = r.en;

        const star = document.createElement("span");
        star.className = "star";
        star.dataset.action = "toggleSentence";
        star.dataset.sentenceId = r.id;
        star.textContent = "‚òÖ";

        enLine.appendChild(document.createTextNode(" "));
        enLine.appendChild(star);

        item.appendChild(enLine);

        if (this.showCN) {
          const cn = document.createElement("div");
          cn.className = "cn";
          cn.textContent = r.cn;
          item.appendChild(cn);
        }

        const meta = document.createElement("div");
        meta.className = "meta";
        meta.textContent = r.fileName ? `Source: ${r.fileName}` : "Source: Other";
        item.appendChild(meta);

        groupEl.appendChild(item);
      }

      frag.appendChild(groupEl);
    }

    this.appEl.appendChild(frag);
  }

  /* ---------- Click handlers ---------- */

  async _handleAppClick(e) {
    const target = e.target;

    // Word click: show popover (also stop auto to avoid skipping while checking words)
    const wordEl = target.closest?.(".word");
    if (wordEl && wordEl.dataset.word) {
      const raw = wordEl.dataset.word;
      const word = String(raw).trim();
      if (word) {
        this.stopAuto();
        await this.showPopover(word, wordEl);
      }
      return;
    }

    // Actions (stars, group delete, sentence TTS, jump)
    const actionEl = target.closest?.("[data-action]");
    if (!actionEl) return;

    const action = actionEl.dataset.action;

    if (action === "playSentence") {
      const idx = Number(actionEl.dataset.idx);
      const s = this.sentences.find(x => x.idx === idx);
      if (s?.en) {
        this.stopAuto();
        await this.speaker.speak(s.en);
      }
      return;
    }

    if (action === "toggleSentence") {
      const sid = actionEl.dataset.sentenceId;
      if (sid) await this.toggleSentenceFavorite(sid);
      return;
    }

    if (action === "toggleWord") {
      const w = actionEl.dataset.word;
      if (w) await this.toggleWordFavorite(w);
      return;
    }

    if (action === "deleteWordGroup") {
      const groupName = actionEl.dataset.groupName || "Other";
      await this.deleteWordGroup(groupName);
      return;
    }

    if (action === "deleteHighlightGroup") {
      const groupName = actionEl.dataset.groupName || "Other";
      await this.deleteHighlightGroup(groupName);
      return;
    }

    if (action === "jumpToSentence") {
      const fileName = String(actionEl.dataset.fileName || "").trim();
      const idx = Number(actionEl.dataset.idx);
      await this.jumpToSentenceIfPossible(fileName, idx);
      return;
    }
  }

  async _handlePopoverClick(e) {
    const actionEl = e.target.closest?.("[data-pop-action]");
    if (!actionEl) return;

    const action = actionEl.dataset.popAction;

    if (action === "toggleWord") {
      if (this.currentPopoverWord) await this.toggleWordFavorite(this.currentPopoverWord);
      return;
    }

    if (action === "playUS") {
      if (!this.currentPopoverWord) return;
      await this.dict.playUS(this.currentPopoverWord);
      return;
    }
  }

  async jumpToSentenceIfPossible(fileName, idx) {
    // Only jump if the currently opened file is the same as the highlight source file
    if (!fileName || !Number.isFinite(idx)) {
      this.hintEl.textContent = "Cannot jump: missing source file info.";
      return;
    }

    if (!this._hasFileLoaded() || this.currentFileName !== fileName) {
      this.hintEl.textContent = `To jump, please load this file in Study: ${fileName}`;
      return;
    }

    const maxIdx = this.sentences.length - 1;
    const targetIdx = Math.max(0, Math.min(idx, maxIdx));

    // Ensure the sentence is visible (extend progress if needed, but do not reduce progress)
    const prev = this.cursor;
    if (this.cursor < targetIdx) {
      this.cursor = targetIdx;
      this.isFinished = (this.cursor >= maxIdx);
      this._saveProgress();
    }

    await this.setView("study");
    this.renderStudy({
      scrollToIdx: targetIdx,
      autoScroll: true
    });

    setTimeout(() => {
      const el = document.getElementById(`sent-${targetIdx}`);
      if (!el) return;

      // Ê∞∏‰πÖÊ†áËÆ∞Ôºà‰∏ãÂàíÁ∫øÔºâ
      el.classList.add("marked");

      // ‰∏¥Êó∂Èó™ËÉåÊôØ
      el.classList.add("flash-bg");
      setTimeout(() => {
        el.classList.remove("flash-bg");
      }, 1100); 
    }, 120);
    
    this._syncControls();
    document.body.focus();
  }

  /* ---------- Popover ---------- */

  async showPopover(word, anchorEl) {
    const w = this.dict.normalize(word);
    if (!w) return;

    this.currentPopoverWord = w;
    this.currentPopoverData = null;

    const saved = this.favoriteWords.has(w);

    this.popoverEl.innerHTML = `
      <h4>${escapeHtml(w)} <span class="star" data-pop-action="toggleWord">${saved ? "‚òÖ" : "‚òÜ"}</span></h4>
      <div class="loading">Loading...</div>
    `;

    this._positionPopover(anchorEl);
    this.popoverEl.style.display = "block";

    const data = await this.dict.lookup(w);
    this.currentPopoverData = data;

    const savedNow = this.favoriteWords.has(w);
    const starChar = savedNow ? "‚òÖ" : "‚òÜ";
    const ipa = data?.ipaUS ? escapeHtml(data.ipaUS) : "";
    const hasUSAudio = !!(data?.audioUS);

    const zhListRaw = String(data?.zhList || []).trim();
    const zhParts = zhListRaw ? zhListRaw.split("\n") : [];
    const zhLines = [];

    // data.zhList is an array from lookup; keep full output, split by delimiter if joined
    if (Array.isArray(data?.zhList)) {
      for (const item of data.zhList) {
        const s = String(item || "").trim();
        if (!s) continue;
        // if joined by "Ôºõ", keep as full; also allow multi-lines
        zhLines.push(...s.split(/\n/).map(x => x.trim()).filter(Boolean));
      }
    }

    // Fallback
    if (zhLines.length === 0) zhLines.push("-");

    this.popoverEl.innerHTML = `
      <h4>${escapeHtml(w)} <span class="star" data-pop-action="toggleWord">${starChar}</span></h4>
      <div class="ipa-line">
        <span>${ipa}</span>
        <span class="speaker ${hasUSAudio ? "" : "disabled"}" data-pop-action="playUS" title="Play US pronunciation">üîä</span>
      </div>
      <div class="cn-def">
        ${zhLines.map(t => `<div class="cn-item">‚Ä¢ ${escapeHtml(t)}</div>`).join("")}
      </div>
    `;

    this._positionPopover(anchorEl, true);
  }

  hidePopover() {
    this.popoverEl.style.display = "none";
    this.currentPopoverWord = null;
    this.currentPopoverData = null;
  }

  _positionPopover(anchorEl, clamp = false) {
    const r = anchorEl.getBoundingClientRect();
    const x0 = r.left + window.scrollX;
    const y0 = r.bottom + window.scrollY + 8;

    this.popoverEl.style.left = `${x0}px`;
    this.popoverEl.style.top = `${y0}px`;

    if (!clamp) return;

    const pr = this.popoverEl.getBoundingClientRect();
    const margin = 10;

    let left = x0;
    let top = y0;

    if (pr.right > window.innerWidth - margin) {
      left = window.scrollX + window.innerWidth - pr.width - margin;
    }
    if (left < window.scrollX + margin) left = window.scrollX + margin;

    if (pr.bottom > window.scrollY + window.innerHeight - margin) {
      top = (r.top + window.scrollY) - pr.height - 8;
    }
    if (top < window.scrollY + margin) top = window.scrollY + margin;

    this.popoverEl.style.left = `${left}px`;
    this.popoverEl.style.top = `${top}px`;
  }

  /* ---------- Favorites ---------- */

  async toggleWordFavorite(word) {
    const w = this.dict.normalize(word);
    if (!w) return;

    const isSaved = this.favoriteWords.has(w);

    if (isSaved) {
      await this.db.del("words", w);
      this.favoriteWords.delete(w);
    } else {
      const data = (this.currentPopoverWord === w && this.currentPopoverData)
        ? this.currentPopoverData
        : await this.dict.lookup(w);

      // Store full Chinese meanings (array), plus compatibility string
      const zhList = Array.isArray(data?.zhList) ? data.zhList : [];
      const zhCompat = zhList.join("\n");

      await this.db.put("words", {
        word: w,
        fileName: this.currentFileName || null,
        zhList: zhList,
        zh: zhCompat,
        ipaUS: data?.ipaUS || "",
        audioUS: data?.audioUS || "",
        savedAt: Date.now()
      });

      this.favoriteWords.add(w);
    }

    // Update popover star if open
    if (this.currentPopoverWord === w && this.popoverEl.style.display === "block") {
      const star = this.popoverEl.querySelector('[data-pop-action="toggleWord"]');
      if (star) star.textContent = this.favoriteWords.has(w) ? "‚òÖ" : "‚òÜ";
    }

    if (this.view === "vocab") await this.renderVocabulary();
  }

  async toggleSentenceFavorite(sentenceId) {
    if (!sentenceId) return;

    const isSaved = this.favoriteSentenceIds.has(sentenceId);

    if (isSaved) {
      await this.db.del("sentences", sentenceId);
      this.favoriteSentenceIds.delete(sentenceId);
    } else {
      // Saving a sentence requires it to exist in the currently loaded file
      if (!this._hasFileLoaded()) return;

      const [fileName, idxStr] = sentenceId.split("::");
      const idx = Number(idxStr);

      const s = this.sentences.find(x => x.idx === idx);
      if (!s) return;

      await this.db.put("sentences", {
        id: sentenceId,
        fileName,
        idx,
        en: s.en,
        cn: s.cn,
        savedAt: Date.now()
      });

      this.favoriteSentenceIds.add(sentenceId);
    }

    if (this.view === "study") this.renderStudy();
    if (this.view === "highlights") await this.renderHighlights();
  }

  /* ---------- Group delete ---------- */

  async deleteWordGroup(groupName) {
    const all = await this.db.getAll("words");
    const target = (groupName === "Other")
      ? all.filter(x => !x.fileName)
      : all.filter(x => x.fileName === groupName);

    if (target.length === 0) return;

    const ok = confirm(`Delete ALL ${target.length} words in group "${groupName}"? This cannot be undone.`);
    if (!ok) return;

    const keys = target.map(x => x.word);
    await this.db.bulkDelete("words", keys);

    keys.forEach(k => this.favoriteWords.delete(k));

    if (this.view === "vocab") await this.renderVocabulary();
  }

  async deleteHighlightGroup(groupName) {
    const all = await this.db.getAll("sentences");
    const target = (groupName === "Other")
      ? all.filter(x => !x.fileName)
      : all.filter(x => x.fileName === groupName);

    if (target.length === 0) return;

    const ok = confirm(`Delete ALL ${target.length} highlights in group "${groupName}"? This cannot be undone.`);
    if (!ok) return;

    const keys = target.map(x => x.id);
    await this.db.bulkDelete("sentences", keys);

    keys.forEach(k => this.favoriteSentenceIds.delete(k));

    if (this.view === "highlights") await this.renderHighlights();
    if (this.view === "study") this.renderStudy();
  }
}

/* Helpers */
function escapeHtml(s) {
  return String(s).replace(/[&<>"']/g, m => ({
    "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"
  }[m]));
}

/* Boot */
const App = new MovieEnglishApp();
App.init();
</script>
</body>
</html>
